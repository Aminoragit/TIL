# 영리한 프로그래밍을 위한 알고리즘
계획 : 알고리즘을 탄탄히 하자! 

->  노트 필기 전부 여기로 다시 정리와 복습,
매일매일 알고리즘 문제 풀기!!! :fire:

- [영리한 프로그래밍을 위한 알고리즘](#영리한-프로그래밍을-위한-알고리즘)
  - [1. 알고리즘의 분석](#1-알고리즘의-분석)
    - [알고리즘의 분석](#알고리즘의-분석)
  - [2. 순환(Recursion)](#2-순환recursion)
    - [순환의 개념과 기본 예제1](#순환의-개념과-기본-예제1)
    - [순환의 개념과 기본 예제2](#순환의-개념과-기본-예제2)
    - [순환의 개념과 기본 예제3](#순환의-개념과-기본-예제3)
    - [Recursion의 응용 - 미로찾기1](#recursion의-응용---미로찾기1)
    - [Recursion의 응용 - n qeeuens problem](#recursion의-응용---n-qeeuens-problem)
  - [3. 정렬](#3-정렬)
    - [기본적인 정렬 알고리즘](#기본적인-정렬-알고리즘)
    - [멱집합(powerset)](#멱집합powerset)
    - [합병정렬(merge sort)](#합병정렬merge-sort)
    - [빠른정렬(quicksort)](#빠른정렬quicksort)
    - [힙 정렬(heap sort) - 1](#힙-정렬heap-sort---1)
    - [힙 정렬(heap sort) - 2](#힙-정렬heap-sort---2)
    - [힙 정렬(heap sort) - 3](#힙-정렬heap-sort---3)
    - [힙의 다른 응용 : 우선순위 큐(priority queue)](#힙의-다른-응용--우선순위-큐priority-queue)
    - [정렬의 lower bound](#정렬의-lower-bound)
    - [sorting in linear time](#sorting-in-linear-time)
    - [sorting in linear time: Radix Sort](#sorting-in-linear-time-radix-sort)
    - [Java에서의 정렬](#java에서의-정렬)
  - [4. 검색트리 - 이진검색트리](#4-검색트리---이진검색트리)
    - [트리와 이진트리](#트리와-이진트리)
    - [이진검색트리(Binary Searcg Tree)](#이진검색트리binary-searcg-tree)
    - [이진검색트리 - 2](#이진검색트리---2)
    - [이진검색트리 - 3](#이진검색트리---3)
  - [5. 검색트리 - 레드불랙트리](#5-검색트리---레드불랙트리)
    - [red block tree - 1](#red-block-tree---1)
    - [red block tree - 2](#red-block-tree---2)
    - [red block tree - 3](#red-block-tree---3)
  - [6. 해슁~](#6-해슁)
    - [hashing - 1](#hashing---1)
    - [hashing - 2](#hashing---2)
    - [hashing - 3](#hashing---3)
  - [7. 그래프 알고리즘](#7-그래프-알고리즘)
    - [그래프(graph) 개념과 표현](#그래프graph-개념과-표현)
    - [순회 - 그래프에서 BFS](#순회---그래프에서-bfs)
    - [순회 - 그래프에서 DFS](#순회---그래프에서-dfs)
    - [DAG 와 위상순서](#dag-와-위상순서)
    - [최소비용신장트리(minimum spanning tree) - 1](#최소비용신장트리minimum-spanning-tree---1)
    - [최소비용신장트리(minimum spanning tree) - 2](#최소비용신장트리minimum-spanning-tree---2)
    - [최소비용신장트리(minimum spanning tree) - 3](#최소비용신장트리minimum-spanning-tree---3)
    - [최소비용신장트리(minimum spanning tree) - 4](#최소비용신장트리minimum-spanning-tree---4)
    - [최단경로(shortest path problem) - 1](#최단경로shortest-path-problem---1)
    - [최단경로(shortest path problem) - 2](#최단경로shortest-path-problem---2)
    - [최단경로(shortest path problem) - 3](#최단경로shortest-path-problem---3)
  - [8. Case Study - Huffman Coding](#8-case-study---huffman-coding)
    - [압축(compression) - 1](#압축compression---1)
    - [압축(compression) - 2](#압축compression---2)
    - [압축(compression) - 3](#압축compression---3)
    - [압축(compression) - 4](#압축compression---4)
    - [압축(compression) - 5](#압축compression---5)
    - [압축(compression) - 6](#압축compression---6)
    - [압축(compression) - 7](#압축compression---7)
  - [9. 동적계획법(Dynamic Programming)](#9-동적계획법dynamic-programming)
    - [Dynamic Programming - 1](#dynamic-programming---1)
    - [Dynamic Programming - 2](#dynamic-programming---2)
    - [Dynamic Programming - 3](#dynamic-programming---3)
    - [Dynamic Programming - 4](#dynamic-programming---4)
    - [Dynamic Programming - 5](#dynamic-programming---5)
    - [Dynamic Programming - 6](#dynamic-programming---6)
  - [보충강의](#보충강의)
    - [보충강의 - 1](#보충강의---1)
    - [보충강의 - 2](#보충강의---2)
    - [보충강의 - 3](#보충강의---3)

---

## 1. 알고리즘의 분석
### 알고리즘의 분석

## 2. 순환(Recursion)
### 순환의 개념과 기본 예제1
### 순환의 개념과 기본 예제2
### 순환의 개념과 기본 예제3
### Recursion의 응용 - 미로찾기1
### Recursion의 응용 - n qeeuens problem

## 3. 정렬
### 기본적인 정렬 알고리즘
### 멱집합(powerset)
### 합병정렬(merge sort)
### 빠른정렬(quicksort)
### 힙 정렬(heap sort) - 1
### 힙 정렬(heap sort) - 2
### 힙 정렬(heap sort) - 3
### 힙의 다른 응용 : 우선순위 큐(priority queue)
### 정렬의 lower bound
### sorting in linear time
### sorting in linear time: Radix Sort
### Java에서의 정렬

## 4. 검색트리 - 이진검색트리
### 트리와 이진트리
### 이진검색트리(Binary Searcg Tree)
### 이진검색트리 - 2
### 이진검색트리 - 3

## 5. 검색트리 - 레드불랙트리
### red block tree - 1
### red block tree - 2
### red block tree - 3

## 6. 해슁~
### hashing - 1
### hashing - 2
### hashing - 3

## 7. 그래프 알고리즘
### 그래프(graph) 개념과 표현
### 순회 - 그래프에서 BFS
### 순회 - 그래프에서 DFS
### DAG 와 위상순서
### 최소비용신장트리(minimum spanning tree) - 1
### 최소비용신장트리(minimum spanning tree) - 2
### 최소비용신장트리(minimum spanning tree) - 3
### 최소비용신장트리(minimum spanning tree) - 4
### 최단경로(shortest path problem) - 1
### 최단경로(shortest path problem) - 2
### 최단경로(shortest path problem) - 3

## 8. Case Study - Huffman Coding
### 압축(compression) - 1
### 압축(compression) - 2
### 압축(compression) - 3
### 압축(compression) - 4
### 압축(compression) - 5
### 압축(compression) - 6
### 압축(compression) - 7

## 9. 동적계획법(Dynamic Programming)
### Dynamic Programming - 1
  Richard Bellman이 개발한 방법론(최단 경로 알고리즘도 개발)

  Motivation

  1. 예시 Fibonacci Numbers
```
int fib(int n)
{
  if(n == 1 || n == 2)
    return 1;
  else
    return fib(n-2) +fib(n-1);
}
```
    위 함수의 문제는 많은 계산이 중복된다 -> 비효율적
    효율적인 방법은?

    Memoization
```
int fib(int n)
{
  if(n == 1 || n == 2)
    return 1;
  else if(f[n] > -1) /*배열 f가 -1으로 초기화되어 있다고 가정*/
    return f[n];    /*즉 이미 계산된 값이라는 의미*/
  else {
    f[n] = fib(n-2) + fib(n-1); /* 중간 계산 결과를 caching */
    return f[n];
  }
}
```
    또다른 방법, Dynamic Programming : bottom up방식
```
int fib(int n)
{
  f[1] = f[2] = 1;
  for (imt i = 3; i <= n; i++)
    f[n] = f[n-1] + f[n-2];
  return f[n];
}
```
    bottom-up 방식으로 중복 계산을 피함.
    
   2. 번쨰 예시
    이항계수(Binimial Coefficient)
```
int binomial(int n, int k)
{
  if(n == k || k == 0) // base case
    return 1;
  else
    return binomial(n - 1, k) + binomial(n - 1, k - 1);// general case
}
```
  제너럴 케이스가 반드시 베이스 케이스에 도달해야 한다.
  그렇지 않으면 무한 으로 빠짐( n >= k)

  Memoization
```
int binomial(int n, int k)
{
  if (n == k || k == 0)
    return 1;
  else if (binom[n][k] > -1) /* 배열 binom이 -1로 초기화되어 있다고 가정 */
  else{
    binom[n][k] = binomial(n-1, k) + binomial(n-1, k-1);
    return binom[n][k];
  }
}
```
  Dynamic Programming
```
int binomial(int n, int k)
{
  for(int i = 0; i <= n; i++){
    for(int j = 0; j <= k && j <= i; j++){
      if( k==0 || n == k)
        binom[i][j] = 1;
      else
        binom[i][j] = binom[i-1][j-1] + binom[i-1][j];
    }
  }
  return binom[n][k];
}
```
    Memoization vs. Dynamic Programming  
 - 순환식의 값을 계산하는 기법들이다.
 - 둘 다 동적계획법의 일종으로 보기도 한다.
 - Momoization은 top-down방식이며, 실제로 필요한 subproblem만을 푼다.
 - 동적계획법은 bottom-up 방식이며, recursion에 수반되는 overhead가 없다.

### Dynamic Programming - 2
  행렬 경로 문제
  - 정수들이 저장된 n x n 행렬의 좌상단에서 우하단까지 이동한다.
    단 오른쪽이나 아래쪽 방향으로만 이동할 수 있다.
  - 방문한 칸에 있는 정수들의 합이 최소화되도록 하라.

  1. 순환식 세우고
  2. 순환식 계산(Memoization, Bommtom up)

  Key Observation
<img src="hhttps://github.com/accidentlywoo/TIL/tree/master/Clever-Algorithm/diagram/dynamic2-1.png" width="30%" height="30%" display="inline-block" alt="연산자 우선순위"/>

  
### Dynamic Programming - 3
### Dynamic Programming - 4
### Dynamic Programming - 5
### Dynamic Programming - 6

## 보충강의
### 보충강의 - 1
### 보충강의 - 2
### 보충강의 - 3